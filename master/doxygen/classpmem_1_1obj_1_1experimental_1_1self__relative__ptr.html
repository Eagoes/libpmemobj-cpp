<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::experimental::self_relative_ptr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.10</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1obj.html">obj</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1obj_1_1experimental.html">experimental</a></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::experimental::self_relative_ptr&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Persistent self-relative pointer class.  
 <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="self__relative__ptr_8hpp_source.html">libpmemobj++/experimental/self_relative_ptr.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pmem::obj::experimental::self_relative_ptr&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.png" usemap="#pmem::obj::experimental::self_5Frelative_5Fptr_3C_20T_20_3E_map" alt=""/>
  <map id="pmem::obj::experimental::self_5Frelative_5Fptr_3C_20T_20_3E_map" name="pmem::obj::experimental::self_5Frelative_5Fptr_3C_20T_20_3E_map">
<area href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html" title="self_relative_ptr base (non-template) class" alt="pmem::obj::experimental::self_relative_ptr_base" shape="rect" coords="0,0,275,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad59315a07c5d3bfd6a761ac17007b23a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ad59315a07c5d3bfd6a761ac17007b23a">iterator_category</a> = std::random_access_iterator_tag</td></tr>
<tr class="memdesc:ad59315a07c5d3bfd6a761ac17007b23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access iterator requirements (members)  <a href="#ad59315a07c5d3bfd6a761ac17007b23a">More...</a><br /></td></tr>
<tr class="separator:ad59315a07c5d3bfd6a761ac17007b23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb09137d75e2485f09eae9fad271af9b"><td class="memItemLeft" align="right" valign="top"><a id="abb09137d75e2485f09eae9fad271af9b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#abb09137d75e2485f09eae9fad271af9b">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:abb09137d75e2485f09eae9fad271af9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> difference type. <br /></td></tr>
<tr class="separator:abb09137d75e2485f09eae9fad271af9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dd724ab1b48eea1fdf7ca077e10078"><td class="memItemLeft" align="right" valign="top"><a id="a48dd724ab1b48eea1fdf7ca077e10078"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a48dd724ab1b48eea1fdf7ca077e10078">value_type</a> = T</td></tr>
<tr class="memdesc:a48dd724ab1b48eea1fdf7ca077e10078"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the value pointed to by the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a>. <br /></td></tr>
<tr class="separator:a48dd724ab1b48eea1fdf7ca077e10078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e38c1e94f1f6e44e06fa69361b8902"><td class="memItemLeft" align="right" valign="top"><a id="a14e38c1e94f1f6e44e06fa69361b8902"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a14e38c1e94f1f6e44e06fa69361b8902">reference</a> = T &amp;</td></tr>
<tr class="memdesc:a14e38c1e94f1f6e44e06fa69361b8902"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reference type of the value pointed to by the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a>. <br /></td></tr>
<tr class="separator:a14e38c1e94f1f6e44e06fa69361b8902"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac76f6b18f3ff9361c1c71227e5bf2234"><td class="memItemLeft" align="right" valign="top"><a id="ac76f6b18f3ff9361c1c71227e5bf2234"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac76f6b18f3ff9361c1c71227e5bf2234">self_relative_ptr</a> () noexcept=default</td></tr>
<tr class="memdesc:ac76f6b18f3ff9361c1c71227e5bf2234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, equal the nullptr. <br /></td></tr>
<tr class="separator:ac76f6b18f3ff9361c1c71227e5bf2234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd56034ec07863366fd5354b28e9a18a"><td class="memItemLeft" align="right" valign="top"><a id="acd56034ec07863366fd5354b28e9a18a"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#acd56034ec07863366fd5354b28e9a18a">self_relative_ptr</a> (std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:acd56034ec07863366fd5354b28e9a18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullptr constructor. <br /></td></tr>
<tr class="separator:acd56034ec07863366fd5354b28e9a18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b186cde38f990d3b7c1a9fd7f68c793"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a0b186cde38f990d3b7c1a9fd7f68c793">self_relative_ptr</a> (element_type *ptr) noexcept</td></tr>
<tr class="memdesc:a0b186cde38f990d3b7c1a9fd7f68c793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volatile pointer constructor.  <a href="#a0b186cde38f990d3b7c1a9fd7f68c793">More...</a><br /></td></tr>
<tr class="separator:a0b186cde38f990d3b7c1a9fd7f68c793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a00f5397ca70925714e517ef7e5cc66"><td class="memItemLeft" align="right" valign="top"><a id="a4a00f5397ca70925714e517ef7e5cc66"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a4a00f5397ca70925714e517ef7e5cc66">self_relative_ptr</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; ptr) noexcept</td></tr>
<tr class="memdesc:a4a00f5397ca70925714e517ef7e5cc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from persistent_ptr&lt;T&gt; <br /></td></tr>
<tr class="separator:a4a00f5397ca70925714e517ef7e5cc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad6b76812c31a4b81859d25846add4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a4ad6b76812c31a4b81859d25846add4b">self_relative_ptr</a> (PMEMoid oid) noexcept</td></tr>
<tr class="memdesc:a4ad6b76812c31a4b81859d25846add4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">PMEMoid constructor.  <a href="#a4ad6b76812c31a4b81859d25846add4b">More...</a><br /></td></tr>
<tr class="separator:a4ad6b76812c31a4b81859d25846add4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe947cc99e3e59a738bfa4f3a624fcd9"><td class="memItemLeft" align="right" valign="top"><a id="abe947cc99e3e59a738bfa4f3a624fcd9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#abe947cc99e3e59a738bfa4f3a624fcd9">self_relative_ptr</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> &amp;ptr) noexcept</td></tr>
<tr class="memdesc:abe947cc99e3e59a738bfa4f3a624fcd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:abe947cc99e3e59a738bfa4f3a624fcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5be3c4ecb9a967cb30425fb3ed54586"><td class="memTemplParams" colspan="2">template&lt;typename U , typename  = typename std::enable_if&lt;			!std::is_same&lt;				typename std::remove_cv&lt;T&gt;::type,				typename std::remove_cv&lt;U&gt;::type&gt;::value &amp;&amp;				!std::is_void&lt;U&gt;::value,			decltype(static_cast&lt;T *&gt;(std::declval&lt;U *&gt;()))&gt;::type&gt; </td></tr>
<tr class="memitem:ac5be3c4ecb9a967cb30425fb3ed54586"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac5be3c4ecb9a967cb30425fb3ed54586">self_relative_ptr</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; U &gt; const &amp;r) noexcept</td></tr>
<tr class="memdesc:ac5be3c4ecb9a967cb30425fb3ed54586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from a different self_relative_ptr&lt;&gt;.  <a href="#ac5be3c4ecb9a967cb30425fb3ed54586">More...</a><br /></td></tr>
<tr class="separator:ac5be3c4ecb9a967cb30425fb3ed54586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c550851f90b7139e588445913fdfb48"><td class="memItemLeft" align="right" valign="top">element_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a9c550851f90b7139e588445913fdfb48">get</a> () const noexcept</td></tr>
<tr class="memdesc:a9c550851f90b7139e588445913fdfb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the direct pointer.  <a href="#a9c550851f90b7139e588445913fdfb48">More...</a><br /></td></tr>
<tr class="separator:a9c550851f90b7139e588445913fdfb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd65672ed7c3bca1cb5eba00f0f89b2"><td class="memItemLeft" align="right" valign="top"><a id="a7cd65672ed7c3bca1cb5eba00f0f89b2"></a>
<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a7cd65672ed7c3bca1cb5eba00f0f89b2">to_persistent_ptr</a> () const</td></tr>
<tr class="memdesc:a7cd65672ed7c3bca1cb5eba00f0f89b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to persitent ptr. <br /></td></tr>
<tr class="separator:a7cd65672ed7c3bca1cb5eba00f0f89b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55b818d5a1bebba2cec1c14b5b03c4d"><td class="memItemLeft" align="right" valign="top"><a id="ae55b818d5a1bebba2cec1c14b5b03c4d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ae55b818d5a1bebba2cec1c14b5b03c4d">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:ae55b818d5a1bebba2cec1c14b5b03c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bool conversion operator. <br /></td></tr>
<tr class="separator:ae55b818d5a1bebba2cec1c14b5b03c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecdc2ba22f7b28676888f087f82ae20"><td class="memItemLeft" align="right" valign="top"><a id="a2ecdc2ba22f7b28676888f087f82ae20"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a2ecdc2ba22f7b28676888f087f82ae20">operator persistent_ptr&lt; T &gt;</a> () const</td></tr>
<tr class="memdesc:a2ecdc2ba22f7b28676888f087f82ae20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator to <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>. <br /></td></tr>
<tr class="separator:a2ecdc2ba22f7b28676888f087f82ae20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0988ed48e3632d8c2483d10f94e5b4c7"><td class="memItemLeft" align="right" valign="top"><a id="a0988ed48e3632d8c2483d10f94e5b4c7"></a>
pmem::detail::sp_dereference&lt; T &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a0988ed48e3632d8c2483d10f94e5b4c7">operator*</a> () const noexcept</td></tr>
<tr class="memdesc:a0988ed48e3632d8c2483d10f94e5b4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference operator. <br /></td></tr>
<tr class="separator:a0988ed48e3632d8c2483d10f94e5b4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52ceb1160a93cf67b2d80ab329757ac"><td class="memItemLeft" align="right" valign="top"><a id="ac52ceb1160a93cf67b2d80ab329757ac"></a>
pmem::detail::sp_member_access&lt; T &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac52ceb1160a93cf67b2d80ab329757ac">operator-&gt;</a> () const noexcept</td></tr>
<tr class="memdesc:ac52ceb1160a93cf67b2d80ab329757ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member access operator. <br /></td></tr>
<tr class="separator:ac52ceb1160a93cf67b2d80ab329757ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fb880992038e280590f619cbe8b041"><td class="memTemplParams" colspan="2">template&lt;typename  = typename std::enable_if&lt;!std::is_void&lt;T&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a95fb880992038e280590f619cbe8b041"><td class="memTemplItemLeft" align="right" valign="top">pmem::detail::sp_array_access&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a95fb880992038e280590f619cbe8b041">operator[]</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#abb09137d75e2485f09eae9fad271af9b">difference_type</a> i) const noexcept</td></tr>
<tr class="memdesc:a95fb880992038e280590f619cbe8b041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array access operator.  <a href="#a95fb880992038e280590f619cbe8b041">More...</a><br /></td></tr>
<tr class="separator:a95fb880992038e280590f619cbe8b041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2283fb5e5ba26aa3a7443a353d062f49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a2283fb5e5ba26aa3a7443a353d062f49">operator=</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> &amp;r)</td></tr>
<tr class="memdesc:a2283fb5e5ba26aa3a7443a353d062f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a2283fb5e5ba26aa3a7443a353d062f49">More...</a><br /></td></tr>
<tr class="separator:a2283fb5e5ba26aa3a7443a353d062f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70042cf9bf7619af8f9f48409e34cf26"><td class="memTemplParams" colspan="2">template&lt;typename Y , typename  = typename std::enable_if&lt;			  std::is_convertible&lt;Y *, T *&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a70042cf9bf7619af8f9f48409e34cf26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a70042cf9bf7619af8f9f48409e34cf26">operator=</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; Y &gt; const &amp;r)</td></tr>
<tr class="memdesc:a70042cf9bf7619af8f9f48409e34cf26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting assignment operator from a different self_relative_ptr&lt;&gt;.  <a href="#a70042cf9bf7619af8f9f48409e34cf26">More...</a><br /></td></tr>
<tr class="separator:a70042cf9bf7619af8f9f48409e34cf26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd01402f0ef7b1c9197aede9a9fa1a1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#acd01402f0ef7b1c9197aede9a9fa1a1c">operator=</a> (std::nullptr_t)</td></tr>
<tr class="memdesc:acd01402f0ef7b1c9197aede9a9fa1a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullptr move assignment operator.  <a href="#acd01402f0ef7b1c9197aede9a9fa1a1c">More...</a><br /></td></tr>
<tr class="separator:acd01402f0ef7b1c9197aede9a9fa1a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6002055eb8589d7119aef75c62e652e8"><td class="memItemLeft" align="right" valign="top"><a id="a6002055eb8589d7119aef75c62e652e8"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a6002055eb8589d7119aef75c62e652e8">operator++</a> ()</td></tr>
<tr class="memdesc:a6002055eb8589d7119aef75c62e652e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix increment operator. <br /></td></tr>
<tr class="separator:a6002055eb8589d7119aef75c62e652e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019147ec67e67e2d0f9844e3356bd549"><td class="memItemLeft" align="right" valign="top"><a id="a019147ec67e67e2d0f9844e3356bd549"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a019147ec67e67e2d0f9844e3356bd549">operator++</a> (int)</td></tr>
<tr class="memdesc:a019147ec67e67e2d0f9844e3356bd549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postfix increment operator. <br /></td></tr>
<tr class="separator:a019147ec67e67e2d0f9844e3356bd549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b94e965b7ac0482e796ef889f5222d0"><td class="memItemLeft" align="right" valign="top"><a id="a5b94e965b7ac0482e796ef889f5222d0"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a5b94e965b7ac0482e796ef889f5222d0">operator--</a> ()</td></tr>
<tr class="memdesc:a5b94e965b7ac0482e796ef889f5222d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix decrement operator. <br /></td></tr>
<tr class="separator:a5b94e965b7ac0482e796ef889f5222d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b38720d3605a098774d9aa448d7b70f"><td class="memItemLeft" align="right" valign="top"><a id="a7b38720d3605a098774d9aa448d7b70f"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a7b38720d3605a098774d9aa448d7b70f">operator--</a> (int)</td></tr>
<tr class="memdesc:a7b38720d3605a098774d9aa448d7b70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postfix decrement operator. <br /></td></tr>
<tr class="separator:a7b38720d3605a098774d9aa448d7b70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04705aad40b6516a6fd81823fe756f95"><td class="memItemLeft" align="right" valign="top"><a id="a04705aad40b6516a6fd81823fe756f95"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a04705aad40b6516a6fd81823fe756f95">operator+=</a> (std::ptrdiff_t s)</td></tr>
<tr class="memdesc:a04705aad40b6516a6fd81823fe756f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. <br /></td></tr>
<tr class="separator:a04705aad40b6516a6fd81823fe756f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7159febd82754998c2902084de5413a8"><td class="memItemLeft" align="right" valign="top"><a id="a7159febd82754998c2902084de5413a8"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a7159febd82754998c2902084de5413a8">operator-=</a> (std::ptrdiff_t s)</td></tr>
<tr class="memdesc:a7159febd82754998c2902084de5413a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator. <br /></td></tr>
<tr class="separator:a7159febd82754998c2902084de5413a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html">pmem::obj::experimental::self_relative_ptr_base</a></td></tr>
<tr class="memitem:a128f481b0e43a6a389952de3e2e3612b inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memItemLeft" align="right" valign="top"><a id="a128f481b0e43a6a389952de3e2e3612b"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#a128f481b0e43a6a389952de3e2e3612b">self_relative_ptr_base</a> () noexcept</td></tr>
<tr class="memdesc:a128f481b0e43a6a389952de3e2e3612b inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, equal the nullptr. <br /></td></tr>
<tr class="separator:a128f481b0e43a6a389952de3e2e3612b inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c27e66a69952b6fe6b1f34c0f731662 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memItemLeft" align="right" valign="top"><a id="a9c27e66a69952b6fe6b1f34c0f731662"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#a9c27e66a69952b6fe6b1f34c0f731662">self_relative_ptr_base</a> (std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a9c27e66a69952b6fe6b1f34c0f731662 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullptr constructor. <br /></td></tr>
<tr class="separator:a9c27e66a69952b6fe6b1f34c0f731662 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf399394afaf43cafa94fcb3b5849a28 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#abf399394afaf43cafa94fcb3b5849a28">self_relative_ptr_base</a> (void *ptr) noexcept</td></tr>
<tr class="memdesc:abf399394afaf43cafa94fcb3b5849a28 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volatile pointer constructor.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#abf399394afaf43cafa94fcb3b5849a28">More...</a><br /></td></tr>
<tr class="separator:abf399394afaf43cafa94fcb3b5849a28 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e4d79b887e88265bb9a57d4d34adb8 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#a47e4d79b887e88265bb9a57d4d34adb8">self_relative_ptr_base</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html">self_relative_ptr_base</a> const &amp;r) noexcept</td></tr>
<tr class="memdesc:a47e4d79b887e88265bb9a57d4d34adb8 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#a47e4d79b887e88265bb9a57d4d34adb8">More...</a><br /></td></tr>
<tr class="separator:a47e4d79b887e88265bb9a57d4d34adb8 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb43a45c7f3eaeb709743e67a940f586 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html">self_relative_ptr_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#acb43a45c7f3eaeb709743e67a940f586">operator=</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html">self_relative_ptr_base</a> const &amp;r)</td></tr>
<tr class="memdesc:acb43a45c7f3eaeb709743e67a940f586 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#acb43a45c7f3eaeb709743e67a940f586">More...</a><br /></td></tr>
<tr class="separator:acb43a45c7f3eaeb709743e67a940f586 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc68a629cb8dadcd0c521f28519e3cac inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html">self_relative_ptr_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#adc68a629cb8dadcd0c521f28519e3cac">operator=</a> (std::nullptr_t &amp;&amp;)</td></tr>
<tr class="memdesc:adc68a629cb8dadcd0c521f28519e3cac inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullptr move assignment operator.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#adc68a629cb8dadcd0c521f28519e3cac">More...</a><br /></td></tr>
<tr class="separator:adc68a629cb8dadcd0c521f28519e3cac inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1ac59e7d2411fd62aa3ec235a7d78b inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#a3c1ac59e7d2411fd62aa3ec235a7d78b">swap</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html">self_relative_ptr_base</a> &amp;other)</td></tr>
<tr class="memdesc:a3c1ac59e7d2411fd62aa3ec235a7d78b inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html" title="self_relative_ptr base (non-template) class">self_relative_ptr_base</a> objects of the same type.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#a3c1ac59e7d2411fd62aa3ec235a7d78b">More...</a><br /></td></tr>
<tr class="separator:a3c1ac59e7d2411fd62aa3ec235a7d78b inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1894b41aea1b9b00a47bde9f202986fa inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memItemLeft" align="right" valign="top"><a id="a1894b41aea1b9b00a47bde9f202986fa"></a>
byte_ptr_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#a1894b41aea1b9b00a47bde9f202986fa">to_byte_pointer</a> () const noexcept</td></tr>
<tr class="memdesc:a1894b41aea1b9b00a47bde9f202986fa inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to byte pointer. <br /></td></tr>
<tr class="separator:a1894b41aea1b9b00a47bde9f202986fa inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84142e67cd193a82efc95858c805a39 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memItemLeft" align="right" valign="top"><a id="af84142e67cd193a82efc95858c805a39"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#af84142e67cd193a82efc95858c805a39">to_void_pointer</a> () const noexcept</td></tr>
<tr class="memdesc:af84142e67cd193a82efc95858c805a39 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to void*. <br /></td></tr>
<tr class="separator:af84142e67cd193a82efc95858c805a39 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbbb3fcfc5ad25fd73342874f563954 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memItemLeft" align="right" valign="top"><a id="a6cbbb3fcfc5ad25fd73342874f563954"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#a6cbbb3fcfc5ad25fd73342874f563954">operator void *</a> () const noexcept</td></tr>
<tr class="memdesc:a6cbbb3fcfc5ad25fd73342874f563954 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit conversion operator to void*. <br /></td></tr>
<tr class="separator:a6cbbb3fcfc5ad25fd73342874f563954 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9639b7856581fb25b2694de6543f2af6 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memItemLeft" align="right" valign="top"><a id="a9639b7856581fb25b2694de6543f2af6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#a9639b7856581fb25b2694de6543f2af6">operator byte_ptr_type</a> () const noexcept</td></tr>
<tr class="memdesc:a9639b7856581fb25b2694de6543f2af6 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit conversion operator to byte pointer. <br /></td></tr>
<tr class="separator:a9639b7856581fb25b2694de6543f2af6 inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166bf3af5b52a54cdd64ea3dae3b02af inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memItemLeft" align="right" valign="top"><a id="a166bf3af5b52a54cdd64ea3dae3b02af"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#a166bf3af5b52a54cdd64ea3dae3b02af">is_null</a> () const noexcept</td></tr>
<tr class="memdesc:a166bf3af5b52a54cdd64ea3dae3b02af inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast null checking without conversion to void*. <br /></td></tr>
<tr class="separator:a166bf3af5b52a54cdd64ea3dae3b02af inherit pub_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html">pmem::obj::experimental::self_relative_ptr_base</a></td></tr>
<tr class="memitem:a9e38bc7ac4b25a4a5c9a3d769751c21a inherit pub_static_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memItemLeft" align="right" valign="top"><a id="a9e38bc7ac4b25a4a5c9a3d769751c21a"></a>
static difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#a9e38bc7ac4b25a4a5c9a3d769751c21a">distance_between</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html">self_relative_ptr_base</a> &amp;first, const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html">self_relative_ptr_base</a> &amp;second)</td></tr>
<tr class="memdesc:a9e38bc7ac4b25a4a5c9a3d769751c21a inherit pub_static_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte distance between two relative pointers. <br /></td></tr>
<tr class="separator:a9e38bc7ac4b25a4a5c9a3d769751c21a inherit pub_static_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html">pmem::obj::experimental::self_relative_ptr_base</a></td></tr>
<tr class="memitem:ab42f96848e7b6527e0cffaeeb332d669 inherit pro_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#ab42f96848e7b6527e0cffaeeb332d669">self_relative_ptr_base</a> (difference_type offset) noexcept</td></tr>
<tr class="memdesc:ab42f96848e7b6527e0cffaeeb332d669 inherit pro_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset constructor.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#ab42f96848e7b6527e0cffaeeb332d669">More...</a><br /></td></tr>
<tr class="separator:ab42f96848e7b6527e0cffaeeb332d669 inherit pro_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bd7030279aeaf8448a2b6d61c5b985 inherit pro_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memItemLeft" align="right" valign="top"><a id="aa5bd7030279aeaf8448a2b6d61c5b985"></a>
difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#aa5bd7030279aeaf8448a2b6d61c5b985">distance_between_self</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html">self_relative_ptr_base</a> &amp;ptr)</td></tr>
<tr class="memdesc:aa5bd7030279aeaf8448a2b6d61c5b985 inherit pro_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self distance between two relative pointers. <br /></td></tr>
<tr class="separator:aa5bd7030279aeaf8448a2b6d61c5b985 inherit pro_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab118d630abb40c31613c215636d2fe73 inherit pro_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memItemLeft" align="right" valign="top"><a id="ab118d630abb40c31613c215636d2fe73"></a>
difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html#ab118d630abb40c31613c215636d2fe73">pointer_to_offset</a> (void *ptr) const noexcept</td></tr>
<tr class="memdesc:ab118d630abb40c31613c215636d2fe73 inherit pro_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion byte pointer to offset. <br /></td></tr>
<tr class="separator:ab118d630abb40c31613c215636d2fe73 inherit pro_methods_classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class pmem::obj::experimental::self_relative_ptr&lt; T &gt;</h3>

<p>Persistent self-relative pointer class. </p>
<p><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> implements a smart ptr. It encapsulates the self offseted pointer and provides member access, dereference and array access operators.</p>
<p>Template parameter type has following requirements:</p><ul>
<li>Is not polymorphic</li>
<li>Has no non-static data members of reference type</li>
<li>Satisfies Destructible requirement: <a href="https://en.cppreference.com/w/cpp/named_req/Destructible">https://en.cppreference.com/w/cpp/named_req/Destructible</a></li>
<li>All non-static data members and base classes follow the same requirements</li>
</ul>
Even if all of the above requirements are met, type representation may vary depending on ABI and compiler optimizations (as stated in [class.mem]: "the order of allocation of non-static data members with different access control is unspecified"). To enforce the same layout for all ABIs and optimization levels type should satisfy StandardLayoutType requirement.If pointer is used with array type, additional requirement is:</p><ul>
<li>Element type must be default constructible</li>
</ul>
The pointer is not designed to work with polymorphic types, as they have runtime RTTI info embedded, which is implementation specific and thus not consistently rebuildable. Such constructs as polymorphic members or members of a union defined within a class held in a pointer will also yield undefined behavior.C++ standard states that lifetime of an object is a runtime property [basic.lifetime]. Conditions which must be fulfilled for object's lifetime to begin, imply that using any non-trivially constructible object with pointer is undefined behaviour. This is being partially addressed by the following proposal: <a href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/bk8esqk-Qoo">https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/bk8esqk-Qoo</a>Another caveat is that snapshotting elements in a transaction and performing rollback uses memcpy internally. Using memcpy on an object in C++ is allowed by the standard only if the type satisfies TriviallyCopyable requirement. </p>
<p>Casting to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__base.html" title="self_relative_ptr base (non-template) class">self_relative_ptr_base</a> can be easily done from any self_relative_ptr&lt;T&gt; objects, but when casting between convertible objects be advised to use constructors or operator= specified for such conversion, see:</p><ul>
<li><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac5be3c4ecb9a967cb30425fb3ed54586" title="Copy constructor from a different self_relative_ptr&lt;&gt;.">self_relative_ptr::self_relative_ptr(self_relative_ptr&lt;U&gt; const &amp;r)</a> ,</li>
<li>self_relative_ptr&lt;T&gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a70042cf9bf7619af8f9f48409e34cf26" title="Converting assignment operator from a different self_relative_ptr&lt;&gt;.">operator=(self_relative_ptr&lt;Y&gt; const &amp;r)</a> . When casting indirectly with (void *) or using static_cast, and then casting to the second (convertible) type, the offset will be re-calculated.</li>
</ul>
<p>The current version uses an approach where we store offset=real_offset-1 and zero offset (or real_offset equal one) is a null pointer. This is needed to support zero initialization.</p><ul>
<li>real_offset = pointer - this;</li>
<li>pointer = real_offset + this;</li>
<li>or pointer = offset + this + 1; </li>
</ul>
 </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad59315a07c5d3bfd6a761ac17007b23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59315a07c5d3bfd6a761ac17007b23a">&#9670;&nbsp;</a></span>iterator_category</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ad59315a07c5d3bfd6a761ac17007b23a">iterator_category</a> =  std::random_access_iterator_tag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Random access iterator requirements (members) </p>
<p>The <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> iterator category. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0b186cde38f990d3b7c1a9fd7f68c793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b186cde38f990d3b7c1a9fd7f68c793">&#9670;&nbsp;</a></span>self_relative_ptr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">element_type *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Volatile pointer constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>volatile pointer, pointing to persistent memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ad6b76812c31a4b81859d25846add4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad6b76812c31a4b81859d25846add4b">&#9670;&nbsp;</a></span>self_relative_ptr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">PMEMoid&#160;</td>
          <td class="paramname"><em>oid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PMEMoid constructor. </p>
<p>Provided for easy interoperability between C++ and C API's.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oid</td><td>C-style persistent pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5be3c4ecb9a967cb30425fb3ed54586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5be3c4ecb9a967cb30425fb3ed54586">&#9670;&nbsp;</a></span>self_relative_ptr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename  = typename std::enable_if&lt;			!std::is_same&lt;				typename std::remove_cv&lt;T&gt;::type,				typename std::remove_cv&lt;U&gt;::type&gt;::value &amp;&amp;				!std::is_void&lt;U&gt;::value,			decltype(static_cast&lt;T *&gt;(std::declval&lt;U *&gt;()))&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor from a different self_relative_ptr&lt;&gt;. </p>
<p>Available only for convertible, non-void types. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9c550851f90b7139e588445913fdfb48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c550851f90b7139e588445913fdfb48">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">element_type* <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the direct pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>the direct pointer to the object. </dd></dl>

</div>
</div>
<a id="a2283fb5e5ba26aa3a7443a353d062f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2283fb5e5ba26aa3a7443a353d062f49">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>self-relative pointer assignment within a transaction automatically registers this operation so that a rollback is possible.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70042cf9bf7619af8f9f48409e34cf26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70042cf9bf7619af8f9f48409e34cf26">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y , typename  = typename std::enable_if&lt;			  std::is_convertible&lt;Y *, T *&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt;T&gt;&amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; Y &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting assignment operator from a different self_relative_ptr&lt;&gt;. </p>
<p>Available only for convertible types. Just like regular assignment, also automatically registers itself in a transaction.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd01402f0ef7b1c9197aede9a9fa1a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd01402f0ef7b1c9197aede9a9fa1a1c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nullptr move assignment operator. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95fb880992038e280590f619cbe8b041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95fb880992038e280590f619cbe8b041">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename  = typename std::enable_if&lt;!std::is_void&lt;T&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pmem::detail::sp_array_access&lt;T&gt;::type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#abb09137d75e2485f09eae9fad271af9b">difference_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array access operator. </p>
<p>Contains run-time bounds checking for static arrays. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/experimental/<a class="el" href="self__relative__ptr_8hpp_source.html">self_relative_ptr.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
